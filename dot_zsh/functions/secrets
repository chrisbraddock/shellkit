#!/bin/bash
# secrets - Manage environment secrets with direnv and 1Password
# Usage:
#   secrets status       - Show current direnv/secrets status
#   secrets init         - Create .envrc template in current directory
#   secrets edit         - Edit .envrc with $EDITOR
#   secrets allow        - Trust current directory's .envrc
#   secrets deny         - Revoke trust for current directory
#   secrets reload       - Reload current directory's environment
#   secrets op-status    - Check 1Password CLI status
#   secrets op-login     - Sign in to 1Password CLI
#   secrets help         - Show this help message

_secrets_status() {
    echo "=== Secret Management Status ==="
    echo ""

    # direnv status
    if command -v direnv &>/dev/null; then
        echo "direnv: installed ($(direnv version))"
        if [[ -f ".envrc" ]]; then
            if direnv status 2>/dev/null | grep -q "Found RC allowed true"; then
                echo "  .envrc: present and allowed"
            else
                echo "  .envrc: present but NOT allowed (run: secrets allow)"
            fi
        else
            echo "  .envrc: not present in current directory"
        fi
    else
        echo "direnv: not installed"
    fi

    echo ""

    # 1Password CLI status
    if command -v op &>/dev/null; then
        echo "1Password CLI: installed ($(op --version))"
        if op account list &>/dev/null 2>&1; then
            local accounts
            accounts=$(op account list --format=json 2>/dev/null | jq -r '.[].email' 2>/dev/null || echo "")
            if [[ -n "$accounts" ]]; then
                echo "  accounts: $accounts"
            fi
        fi
        if op whoami &>/dev/null 2>&1; then
            echo "  session: active"
        else
            echo "  session: not signed in (run: secrets op-login)"
        fi
    else
        echo "1Password CLI: not installed"
        echo "  install: brew install --cask 1password-cli"
    fi
}

_secrets_init() {
    if [[ -f ".envrc" ]]; then
        echo "Error: .envrc already exists in current directory" >&2
        echo "Use 'secrets edit' to modify it" >&2
        return 1
    fi

    local has_op=""
    if command -v op &>/dev/null; then
        has_op="true"
    fi

    cat > .envrc <<'ENVRC'
# Environment secrets for this project
# Loaded automatically by direnv when entering this directory
#
# After editing, run: direnv allow

# Example: Static secrets (not recommended for shared repos)
# export API_KEY="your-api-key-here"

ENVRC

    if [[ -n "$has_op" ]]; then
        cat >> .envrc <<'ENVRC'
# Example: Load secrets from 1Password (recommended)
# export OPENAI_API_KEY=$(op read "op://Development/OpenAI/api-key")
# export GITHUB_TOKEN=$(op read "op://Development/GitHub CLI/token")
# export AWS_ACCESS_KEY_ID=$(op read "op://Development/AWS/access-key-id")
# export AWS_SECRET_ACCESS_KEY=$(op read "op://Development/AWS/secret-access-key")
ENVRC
    fi

    echo "Created .envrc in $(pwd)"
    echo ""
    echo "Next steps:"
    echo "  1. Edit the file: secrets edit"
    echo "  2. Allow direnv:  secrets allow"
    echo ""
    echo "Security reminder: Add .envrc to .gitignore if it contains secrets"
}

_secrets_edit() {
    if [[ ! -f ".envrc" ]]; then
        echo "No .envrc in current directory. Create one with: secrets init" >&2
        return 1
    fi

    ${EDITOR:-vim} .envrc

    echo ""
    echo "After editing, run 'secrets allow' to reload"
}

_secrets_allow() {
    if ! command -v direnv &>/dev/null; then
        echo "Error: direnv not installed" >&2
        return 1
    fi

    if [[ ! -f ".envrc" ]]; then
        echo "No .envrc in current directory" >&2
        return 1
    fi

    direnv allow
}

_secrets_deny() {
    if ! command -v direnv &>/dev/null; then
        echo "Error: direnv not installed" >&2
        return 1
    fi

    direnv deny
}

_secrets_reload() {
    if ! command -v direnv &>/dev/null; then
        echo "Error: direnv not installed" >&2
        return 1
    fi

    direnv reload
}

_secrets_op_status() {
    if ! command -v op &>/dev/null; then
        echo "1Password CLI not installed" >&2
        echo "Install: brew install --cask 1password-cli" >&2
        return 1
    fi

    echo "1Password CLI version: $(op --version)"
    echo ""

    if op whoami &>/dev/null 2>&1; then
        echo "Session: Active"
        op whoami
    else
        echo "Session: Not signed in"
        echo ""
        echo "Run 'secrets op-login' to sign in"
    fi
}

_secrets_op_login() {
    if ! command -v op &>/dev/null; then
        echo "1Password CLI not installed" >&2
        echo "Install: brew install --cask 1password-cli" >&2
        return 1
    fi

    # Check if already signed in
    if op whoami &>/dev/null 2>&1; then
        echo "Already signed in to 1Password"
        op whoami
        return 0
    fi

    # Check for accounts
    if ! op account list &>/dev/null 2>&1; then
        echo "No 1Password accounts configured."
        echo ""
        echo "First-time setup:"
        echo "  1. Open 1Password app"
        echo "  2. Go to Settings > Developer"
        echo "  3. Enable 'Integrate with 1Password CLI'"
        echo ""
        echo "Then run: op signin"
        return 1
    fi

    eval "$(op signin)"
}

_secrets_help() {
    cat <<'EOF'
secrets - Manage environment secrets with direnv and 1Password

USAGE:
    secrets <command>

COMMANDS:
    status       Show current direnv and 1Password status (default)
    init         Create .envrc template in current directory
    edit         Edit .envrc with $EDITOR
    allow        Trust current directory's .envrc
    deny         Revoke trust for current directory
    reload       Reload current directory's environment
    op-status    Check 1Password CLI status
    op-login     Sign in to 1Password CLI
    help         Show this help message

WORKFLOW:
    1. cd into your project directory
    2. secrets init          # Create .envrc template
    3. secrets edit          # Add your secrets
    4. secrets allow         # Trust and load the file

WITH 1PASSWORD:
    Instead of hardcoding secrets, reference them from 1Password:

        export API_KEY=$(op read "op://Vault/Item/field")

    The secret is fetched when .envrc loads and stays in memory only.

SECURITY:
    - .envrc files should be in .gitignore
    - direnv requires explicit 'allow' before sourcing any .envrc
    - 1Password CLI uses biometric or password authentication
    - Secrets loaded from 1Password are never written to disk

EXAMPLES:
    secrets status                    # Check what's configured
    secrets init && secrets edit      # Create and edit .envrc
    op read "op://Dev/OpenAI/key"     # Read a secret from 1Password
EOF
}

# Main dispatch
case "${1:-status}" in
    status)
        _secrets_status
        ;;
    init)
        _secrets_init
        ;;
    edit)
        _secrets_edit
        ;;
    allow)
        _secrets_allow
        ;;
    deny)
        _secrets_deny
        ;;
    reload)
        _secrets_reload
        ;;
    op-status)
        _secrets_op_status
        ;;
    op-login)
        _secrets_op_login
        ;;
    help|--help|-h)
        _secrets_help
        ;;
    *)
        echo "Unknown subcommand: $1" >&2
        echo "Usage: secrets {status|init|edit|allow|deny|reload|op-status|op-login|help}" >&2
        return 1
        ;;
esac
